<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REHABAND App - BLE</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            max-width: 375px;
            margin: 0 auto;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px 20px;
        }
        
        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        
        .header h1 {
            font-size: 20px;
        }
        
        .session-type {
            font-size: 10px;
            background: rgba(255,255,255,0.25);
            padding: 4px 8px;
            border-radius: 10px;
        }
        
        .status {
            font-size: 11px;
            opacity: 0.9;
        }
        
        .status-dot {
            display: inline-block;
            width: 6px;
            height: 6px;
            background: #ef4444;
            border-radius: 50%;
            margin-right: 4px;
            transition: background-color 0.3s ease;
        }

        .status-dot.connected {
            background: #4ade80;
        }

        .connect-btn {
            width: calc(100% - 24px);
            margin: 12px;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .connect-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .connect-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .summary {
            background: white;
            padding: 14px 16px;
            margin: 12px;
            border-radius: 12px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.06);
        }
        
        .summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .summary h2 {
            font-size: 14px;
            color: #333;
        }
        
        .duration {
            font-size: 11px;
            color: #667eea;
            background: #e0e7ff;
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 600;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .stat {
            text-align: center;
            padding: 8px;
            background: #f8f9ff;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .stat.updated {
            background: #e0e7ff;
            transform: scale(1.05);
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
        }
        
        .stat-label {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
        }
        
        .rep-list {
            padding: 0 12px 16px;
        }
        
        .rep-list h3 {
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .rep-card {
            background: white;
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.04);
            transition: all 0.3s ease;
            opacity: 0;
            transform: translateY(20px);
        }

        .rep-card.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .rep-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .rep-number {
            font-size: 15px;
            font-weight: bold;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .rep-icon {
            width: 26px;
            height: 26px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        .overall-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .badge-good {
            background: #dcfce7;
            color: #16a34a;
        }
        
        .badge-caution {
            background: #fef9c3;
            color: #ca8a04;
        }
        
        .badge-bad {
            background: #fee2e2;
            color: #dc2626;
        }
        
        .metrics {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: #fafafa;
            border-radius: 6px;
        }
        
        .metric-label {
            font-size: 12px;
            color: #666;
        }
        
        .metric-value {
            font-size: 12px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 5px;
        }
        
        .value-good {
            background: #dcfce7;
            color: #16a34a;
        }
        
        .value-caution {
            background: #fef9c3;
            color: #ca8a04;
        }
        
        .value-bad {
            background: #fee2e2;
            color: #dc2626;
        }

        .error-message {
            background: #fee2e2;
            color: #dc2626;
            padding: 12px;
            margin: 12px;
            border-radius: 8px;
            font-size: 12px;
            display: none;
        }

        .instructions {
            background: #f0f9ff;
            color: #0369a1;
            padding: 6px 10px;
            margin: 6px 12px;
            border-radius: 6px;
            font-size: 10px;
            line-height: 1.2;
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .settings-section {
            background: white;
            padding: 14px 16px;
            margin: 0 12px 12px;
            border-radius: 12px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.06);
        }

        .settings-section h3 {
            font-size: 13px;
            color: #333;
            margin-bottom: 12px;
            font-weight: 600;
        }

        .setting-item {
            margin-bottom: 10px;
        }

        .setting-label {
            font-size: 11px;
            color: #666;
            margin-bottom: 6px;
            display: block;
        }

        .setting-control {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #f8f9ff;
            border-radius: 8px;
            padding: 8px 12px;
        }

        .control-buttons {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .control-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            background: #667eea;
            color: white;
            transform: scale(1.05);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .control-value {
            font-size: 16px;
            font-weight: bold;
            color: #667eea;
            min-width: 60px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .control-value.updated {
            transform: scale(1.1);
            color: #16a34a;
        }

        .control-unit {
            font-size: 11px;
            color: #999;
            margin-left: 2px;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-top">
            <h1>REHABAND</h1>
            <span class="session-type">Live Session</span>
        </div>
        <div class="status">
            <span class="status-dot" id="statusDot"></span>
            <span id="statusText">Not Connected</span>
        </div>
    </div>

    <button class="connect-btn" id="connectBtn">Connect to REHABAND</button>

    <button class="connect-btn" id="demoBtn" style="background: linear-gradient(135deg, #16a34a 0%, #15803d 100%); margin-top: 8px;">Try Demo Mode</button>

    <!-- Session Controls Section -->
    <div class="session-controls" style="margin: 12px; background: white; border-radius: 12px; padding: 16px; box-shadow: 0 2px 6px rgba(0,0,0,0.06);">
        <h3 style="font-size: 14px; color: #333; margin-bottom: 12px; font-weight: 600; text-align: center;">Session Controls</h3>
        <div style="display: flex; gap: 8px;">
            <button class="connect-btn" id="startResetBtn" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); flex: 1; opacity: 0.5; cursor: not-allowed;" disabled>Start Session</button>
            <button class="connect-btn" id="calibrateBtn" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); flex: 1; opacity: 0.5; cursor: not-allowed;" disabled>Calibrate (5 Reps)</button>
        </div>
        <div style="font-size: 10px; color: #666; text-align: center; margin-top: 8px; font-style: italic;" id="sessionControlsStatus">Connect to device to enable session controls</div>
    </div>

    <div class="error-message" id="errorMessage"></div>

    <div class="instructions">
        <strong>Instructions:</strong><br>
        <strong>Real Device:</strong> 1) Upload Arduino sketch to Nano 33 BLE, 2) Mount device 3cm above kneecap on thigh, 3) Click "Connect to REHABAND", 4) Click "Calibrate (5 Reps)" and perform 5 perfect squats, 5) Use "Start Session" to begin tracking<br>
        <strong>Demo:</strong> Click "Try Demo Mode" to see the interface with simulated squat data (set ROM=90°, Speed=30°/s for best demo results)
    </div>

    <div class="summary">
        <div class="summary-header">
            <h2>Session Summary</h2>
            <span class="duration" id="duration">0 mins</span>
        </div>
        <div class="stats">
            <div class="stat" id="totalRepsStat">
                <div class="stat-value" id="totalReps">0</div>
                <div class="stat-label">Total Reps</div>
            </div>
            <div class="stat" id="goodRepsStat">
                <div class="stat-value" id="goodReps">0</div>
                <div class="stat-label">Good Form</div>
            </div>
            <div class="stat" id="avgAngleStat">
                <div class="stat-value" id="avgAngle">--</div>
                <div class="stat-label">Avg Angle</div>
            </div>
        </div>
    </div>

    <div class="settings-section">
        <h3>Adjust Settings</h3>
        <div style="font-size: 10px; color: #666; text-align: center; margin-bottom: 12px; font-style: italic;">Changes apply instantly to connected device</div>
        <div id="demoDisclaimer" style="font-size: 9px; color: #dc2626; margin-bottom: 8px; font-style: italic; display: none;">
            <strong>Demo Mode:</strong> For best results, set Target ROM to <strong>90°</strong> and Max Speed to <strong>30°/s</strong><br>
            This will show Rep 1 and Rep 3 as "Good" examples.
        </div>
        
        <div class="setting-item">
            <label class="setting-label">Target ROM</label>
            <div class="setting-control">
                <button class="control-btn" id="romDecBtn">−</button>
                <div class="control-value" id="romValue">95<span class="control-unit">°</span></div>
                <button class="control-btn" id="romIncBtn">+</button>
            </div>
        </div>

        <div class="setting-item">
            <label class="setting-label">Max Speed for "Controlled" Rating</label>
            <div class="setting-control">
                <button class="control-btn" id="speedDecBtn">−</button>
                <div class="control-value" id="speedValue">30<span class="control-unit">°/s</span></div>
                <button class="control-btn" id="speedIncBtn">+</button>
            </div>
        </div>

        <div class="setting-item">
            <label class="setting-label">Sound Alerts</label>
            <div class="setting-control">
                <button class="control-btn" id="soundToggleBtn" style="width: auto; padding: 0 12px; border-radius: 6px;">ON</button>
            </div>
        </div>

    </div>

    <div class="rep-list">
        <h3>Rep History</h3>
        <div id="repContainer">
            <div style="text-align: center; color: #999; font-size: 12px; padding: 20px;" id="noRepsMessage">
                No reps yet. Start exercising to see data!
            </div>
        </div>
    </div>

    <script>
        let device, server, service;
        let romChar, speedChar, jerkinessChar, repCountChar, sessionControlChar, calibrationChar, targetROMChar, targetSpeedChar;
        let repsData = [];
        let sessionStartTime;
        let lastRepCount = 0;
        let isSessionActive = false;
        let isCalibrating = false;
        let calibrationData = [];
        let calibrationCount = 0;

        // Settings variables  
        let settings = {
            targetROM: 95,
            speedTarget: 30.0, // Now angular velocity in deg/s (lower = more controlled)
            soundAlerts: true
        };

        const connectBtn = document.getElementById('connectBtn');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const repContainer = document.getElementById('repContainer');
        const errorMessage = document.getElementById('errorMessage');
        const noRepsMessage = document.getElementById('noRepsMessage');

        const demoBtn = document.getElementById('demoBtn');
        const startResetBtn = document.getElementById('startResetBtn');

        // Settings elements
        const romDecBtn = document.getElementById('romDecBtn');
        const romIncBtn = document.getElementById('romIncBtn');
        const romValue = document.getElementById('romValue');
        const speedDecBtn = document.getElementById('speedDecBtn');
        const speedIncBtn = document.getElementById('speedIncBtn');
        const speedValue = document.getElementById('speedValue');
        const soundToggleBtn = document.getElementById('soundToggleBtn');
        const demoDisclaimer = document.getElementById('demoDisclaimer');
        const calibrateBtn = document.getElementById('calibrateBtn');
        const sessionControlsStatus = document.querySelector('.session-controls div:last-child');

        connectBtn.addEventListener('click', connectToDevice);
        demoBtn.addEventListener('click', startDemoMode);
        startResetBtn.addEventListener('click', toggleSession);
        calibrateBtn.addEventListener('click', startCalibration);

        // Settings event listeners
        romDecBtn.addEventListener('click', () => adjustSetting('rom', -5));
        romIncBtn.addEventListener('click', () => adjustSetting('rom', 5));
        speedDecBtn.addEventListener('click', () => adjustSetting('speed', -2.0)); // Adjust by 2 deg/s
        speedIncBtn.addEventListener('click', () => adjustSetting('speed', 2.0));
        soundToggleBtn.addEventListener('click', toggleSoundAlerts);

        // Check if Web Bluetooth is supported
        if (!navigator.bluetooth) {
            showError('Web Bluetooth is not supported. Please use Chrome or Edge browser.');
            connectBtn.disabled = true;
        }

        async function connectToDevice() {
            try {
                hideError();
                connectBtn.disabled = true;
                connectBtn.textContent = 'Connecting...';

                // Request device
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ name: 'REHABAND' }],
                    optionalServices: [0x180D]
                });

                // Connect to GATT server
                statusText.textContent = 'Connecting to device...';
                server = await device.gatt.connect();
                
                // Get service
                statusText.textContent = 'Getting service...';
                service = await server.getPrimaryService(0x180D);

                // Get characteristics
                statusText.textContent = 'Getting characteristics...';
                romChar = await service.getCharacteristic(0x2A37);
                speedChar = await service.getCharacteristic(0x2A38);
                jerkinessChar = await service.getCharacteristic(0x2A39);
                repCountChar = await service.getCharacteristic(0x2A3A);
                
                // Try to get session control characteristic
                try {
                    sessionControlChar = await service.getCharacteristic(0x2A3B);
                } catch (error) {
                    console.log('Session control characteristic not available:', error.message);
                }
                
                // Try to get calibration and target characteristics
                try {
                    calibrationChar = await service.getCharacteristic(0x2A3C);
                    targetROMChar = await service.getCharacteristic(0x2A3D);
                    targetSpeedChar = await service.getCharacteristic(0x2A3E);
                    console.log('Calibration characteristics available');
                } catch (error) {
                    console.log('Calibration characteristics not available:', error.message);
                }

                // Start notifications
                statusText.textContent = 'Starting notifications...';
                await repCountChar.startNotifications();
                repCountChar.addEventListener('characteristicvaluechanged', handleRepCountChange);
                
                // Start calibration notifications if available
                if (calibrationChar) {
                    await calibrationChar.startNotifications();
                    calibrationChar.addEventListener('characteristicvaluechanged', handleCalibrationChange);
                }

                // Connection successful
                statusDot.classList.add('connected');
                statusText.textContent = 'Connected';
                connectBtn.textContent = 'Connected ✓';
                connectBtn.style.background = '#16a34a';
                
                // Send current settings to Arduino immediately upon connection
                await sendSettingsToArduino();
                
                // Enable session controls
                startResetBtn.disabled = false;
                startResetBtn.style.opacity = '1';
                startResetBtn.style.cursor = 'pointer';
                calibrateBtn.disabled = false;
                calibrateBtn.style.opacity = '1';
                calibrateBtn.style.cursor = 'pointer';
                sessionControlsStatus.textContent = '✨ First time? Click "Calibrate" to personalize your targets!';
                
                sessionStartTime = Date.now();
                updateDuration();

                // Add disconnect handler
                device.addEventListener('gattserverdisconnected', onDisconnected);

                console.log('Successfully connected to REHABAND device');

            } catch (error) {
                console.error('Connection failed:', error);
                showError(`Connection failed: ${error.message}`);
                resetConnectionState();
            }
        }

        async function handleRepCountChange(event) {
            try {
                const repNumber = event.target.value.getUint8(0);
                
                // Only process if it's a new rep
                if (repNumber > lastRepCount && repNumber <= 10) {
                    lastRepCount = repNumber;
                    
                    // Read other characteristics
                    const romValue = await romChar.readValue();
                    const speedValue = await speedChar.readValue();
                    const jerkinessValue = await jerkinessChar.readValue();

                    const rom = romValue.getUint8(0);
                    const speed = speedValue.getFloat32(0, true); // Now angular velocity (deg/s)
                    const jerkiness = jerkinessValue.getFloat32(0, true); // Now RMS jerk value

                    console.log(`Rep ${repNumber}: ROM=${rom}°, Speed=${speed}s, Jerkiness=${jerkiness}`);
                    
                    addRepCard(repNumber, rom, speed, jerkiness);
                    updateSummary();
                }
            } catch (error) {
                console.error('Error handling rep data:', error);
                showError(`Error reading rep data: ${error.message}`);
            }
        }

        async function handleCalibrationChange(event) {
            try {
                const calibrationStatus = event.target.value.getUint8(0);
                
                if (calibrationStatus === 1) {
                    // Calibration progress update - Arduino completed a calibration squat
                    console.log('Calibration progress update received');
                    
                    // The repCountChar should now have the current calibration rep count
                    if (repCountChar) {
                        try {
                            const repValue = await repCountChar.readValue();
                            const currentCalibrationRep = repValue.getUint8(0);
                            
                            // Update button text with progress
                            calibrateBtn.textContent = `Calibrating... (${currentCalibrationRep}/5)`;
                            sessionControlsStatus.textContent = `Calibration progress: ${currentCalibrationRep}/5 squats completed`;
                            
                            console.log(`Calibration progress: ${currentCalibrationRep}/5 squats completed`);
                        } catch (error) {
                            console.error('Error reading calibration rep count:', error);
                        }
                    }
                } else if (calibrationStatus === 2) {
                    // Calibration complete - read new target values
                    console.log('Calibration complete signal received');
                    
                    if (targetROMChar && targetSpeedChar) {
                        const romValue = await targetROMChar.readValue();
                        const speedValue = await targetSpeedChar.readValue();
                        
                        const newROM = romValue.getFloat32(0, true);
                        const newSpeed = speedValue.getFloat32(0, true);
                        
                        // Update settings with calibrated values
                        settings.targetROM = Math.round(newROM);
                        settings.speedTarget = parseFloat(newSpeed.toFixed(1));
                        
                        // Update display
                        updateSettingDisplay('rom', settings.targetROM);
                        updateSettingDisplay('speed', settings.speedTarget);
                        
                        // Save to localStorage
                        saveSettings();
                        
                        console.log(`Calibration updated: ROM=${settings.targetROM}°, Speed=${settings.speedTarget}°/s`);
                    }
                    
                    // Reset calibration state
                    isCalibrating = false;
                    calibrateBtn.textContent = 'Calibrate (5 Reps)';
                    calibrateBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    calibrateBtn.disabled = false;
                    sessionControlsStatus.textContent = 'Calibration complete! Ready for sessions';
                    
                    showError(`Calibration complete! New targets: ${settings.targetROM}° ROM, ${settings.speedTarget}°/s speed`);
                    setTimeout(hideError, 5000);
                }
            } catch (error) {
                console.error('Error handling calibration data:', error);
                showError(`Calibration error: ${error.message}`);
            }
        }

        function addRepCard(repNum, rom, speed, jerkiness) {
            // Handle calibration mode
            if (isCalibrating) {
                handleCalibrationRep(rom, speed, jerkiness);
                return; // Don't show individual rep cards during calibration
            }
            
            // Hide "no reps" message
            noRepsMessage.style.display = 'none';
            
            // Determine jerkiness text and status from RMS jerk value
            let jerkinessText, jerkinessStatus;
            if (jerkiness < 50) {
                jerkinessText = 'Smooth';
                jerkinessStatus = 'good';
            } else if (jerkiness < 150) {
                jerkinessText = 'Moderate';
                jerkinessStatus = 'caution';
            } else {
                jerkinessText = 'Jerky';
                jerkinessStatus = 'bad';
            }
            
            // Determine speed text and status using angular velocity (deg/s)
            // Lower speed = more controlled = better for rehabilitation
            const speedTarget = settings.speedTarget; // Now in deg/s
            let speedText, speedStatus;
            if (speed <= speedTarget) {
                speedText = 'Controlled';
                speedStatus = 'good';
            } else if (speed <= speedTarget * 1.5) {
                speedText = 'Moderate';
                speedStatus = 'caution';
            } else {
                speedText = 'Too Fast';
                speedStatus = 'bad';
            }
            
            // Determine ROM status using dynamic thresholds
            const romTarget = settings.targetROM;
            const romTolerance = 10; // ±10 degrees
            const romStatus = (rom >= (romTarget - romTolerance) && rom <= (romTarget + romTolerance)) ? 'good' : 
                             (rom >= (romTarget - 25) && rom <= (romTarget + 25)) ? 'caution' : 'bad';
            
            // jerkinessStatus already determined above
            
            // Determine overall badge
            const overallBadge = (romStatus === 'good' && speedStatus === 'good' && jerkinessStatus === 'good') ? 'good' :
                                 (romStatus === 'bad' || speedStatus === 'bad' || jerkinessStatus === 'bad') ? 'bad' : 'caution';

            // Debug logging for demo mode
            console.log(`Rep ${repNum}: ROM=${rom}° (${romStatus}), Speed=${speed}s (${speedStatus}), Jerkiness=${jerkiness} (${jerkinessStatus}) → Overall: ${overallBadge}`);

            const repCard = document.createElement('div');
            repCard.className = 'rep-card';
            repCard.innerHTML = `
                <div class="rep-header">
                    <div class="rep-number">
                        <span class="rep-icon">${repNum}</span>
                        Rep ${repNum}
                    </div>
                    <span class="overall-badge badge-${overallBadge}">
                        ${overallBadge === 'good' ? 'Good' : overallBadge === 'caution' ? 'Caution' : 'Poor'}
                    </span>
                </div>
                <div class="metrics">
                    <div class="metric-row">
                        <span class="metric-label">ROM Angle</span>
                        <span class="metric-value value-${romStatus}">${rom}°</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Speed</span>
                        <span class="metric-value value-${speedStatus}">${speedText}</span>
                    </div>
                    <div class="metric-row">
                        <span class="metric-label">Smoothness</span>
                        <span class="metric-value value-${jerkinessStatus}">${jerkinessText}</span>
                    </div>
                </div>
            `;

            // Add to top of container with animation
            repContainer.insertBefore(repCard, repContainer.firstChild);
            
            // Trigger animation
            setTimeout(() => {
                repCard.classList.add('show');
            }, 50);

            // Store rep data
            repsData.push({ rom, speed, jerkiness, status: overallBadge });

            // Play sound alert for poor form
            if (settings.soundAlerts) {
                playSoundAlert(overallBadge);
            }
        }

        function updateSummary() {
            // Update total reps
            document.getElementById('totalReps').textContent = repsData.length;
            animateStatUpdate('totalRepsStat');
            
            // Update good reps count
            const goodReps = repsData.filter(r => r.status === 'good').length;
            document.getElementById('goodReps').textContent = goodReps;
            animateStatUpdate('goodRepsStat');
            
            // Update average ROM angle
            if (repsData.length > 0) {
                const avgRom = Math.round(repsData.reduce((sum, r) => sum + r.rom, 0) / repsData.length);
                document.getElementById('avgAngle').textContent = avgRom + '°';
                animateStatUpdate('avgAngleStat');
            }
        }

        function animateStatUpdate(statId) {
            const stat = document.getElementById(statId);
            stat.classList.add('updated');
            setTimeout(() => {
                stat.classList.remove('updated');
            }, 300);
        }

        function updateDuration() {
            if (!sessionStartTime) return;
            const elapsed = Math.floor((Date.now() - sessionStartTime) / 60000);
            document.getElementById('duration').textContent = elapsed + ' min' + (elapsed !== 1 ? 's' : '');
            setTimeout(updateDuration, 10000); // Update every 10 seconds
        }

        function onDisconnected() {
            console.log('Device disconnected');
            resetConnectionState();
            showError('Device disconnected. Please reconnect to continue.');
        }

        function resetConnectionState() {
            statusDot.classList.remove('connected');
            statusText.textContent = 'Not Connected';
            connectBtn.disabled = false;
            connectBtn.textContent = 'Connect to REHABAND';
            connectBtn.style.background = '';
            
            // Disable session controls
            startResetBtn.disabled = true;
            startResetBtn.style.opacity = '0.5';
            startResetBtn.style.cursor = 'not-allowed';
            calibrateBtn.disabled = true;
            calibrateBtn.style.opacity = '0.5';
            calibrateBtn.style.cursor = 'not-allowed';
            sessionControlsStatus.textContent = 'Connect to device to enable session controls';
            
            // Reset session state
            isSessionActive = false;
            startResetBtn.textContent = 'Start Session';
            startResetBtn.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
            
            // Reset calibration state
            if (isCalibrating) {
                isCalibrating = false;
                calibrateBtn.textContent = 'Calibrate (5 Reps)';
                calibrateBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            }
            
            // Reset session data
            sessionStartTime = null;
            lastRepCount = 0;
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }

        function hideError() {
            errorMessage.style.display = 'none';
        }

        // Session Control Functions
        async function toggleSession() {
            if (!isSessionActive) {
                // Start session
                isSessionActive = true;
                startResetBtn.textContent = 'Reset Session';
                startResetBtn.style.background = 'linear-gradient(135deg, #dc2626 0%, #b91c1c 100%)';
                
                // Send start command to Arduino with retry logic
                if (sessionControlChar) {
                    try {
                        await writeCharacteristicWithRetry(sessionControlChar, new Uint8Array([1]));
                        console.log('Start session command sent to Arduino');
                    } catch (error) {
                        console.error('Failed to send start command after retries:', error);
                        showError(`Failed to start session: ${error.message}`);
                    }
                }
                
                // Reset local session data
                repsData = [];
                lastRepCount = 0;
                sessionStartTime = Date.now();
                updateDuration();
                updateSummary();
                
                // Clear rep history display
                repContainer.innerHTML = '<div style="text-align: center; color: #999; font-size: 12px; padding: 20px;" id="noRepsMessage">Session started! Begin exercising to see data.</div>';
                
                sessionControlsStatus.textContent = 'Session active - exercising...';
                showError('Session started! Current angle set as reference position.');
                setTimeout(hideError, 3000);
                
            } else {
                // Reset session
                isSessionActive = false;
                startResetBtn.textContent = 'Start Session';
                startResetBtn.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
                
                // Send reset command to Arduino with retry logic
                if (sessionControlChar) {
                    try {
                        await writeCharacteristicWithRetry(sessionControlChar, new Uint8Array([0]));
                        console.log('Reset session command sent to Arduino');
                    } catch (error) {
                        console.error('Failed to send reset command after retries:', error);
                        showError(`Failed to reset session: ${error.message}`);
                    }
                }
                
                // Reset session data
                repsData = [];
                lastRepCount = 0;
                sessionStartTime = Date.now();
                updateSummary();
                
                // Reset stats display
                document.getElementById('totalReps').textContent = '0';
                document.getElementById('goodReps').textContent = '0';
                document.getElementById('avgAngle').textContent = '--';
                
                // Clear rep history display
                repContainer.innerHTML = '<div style="text-align: center; color: #999; font-size: 12px; padding: 20px;" id="noRepsMessage">Session reset. Start exercising to see data!</div>';
                
                sessionControlsStatus.textContent = 'Ready to start session or calibrate';
                showError('Session reset successfully!');
                setTimeout(hideError, 3000);
            }
        }

        // BLE Retry Helper Function
        async function writeCharacteristicWithRetry(characteristic, value, maxRetries = 3, delay = 100) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    await characteristic.writeValue(value);
                    console.log(`BLE write successful on attempt ${attempt}`);
                    return true;
                } catch (error) {
                    console.warn(`BLE write attempt ${attempt} failed:`, error.message);
                    
                    if (attempt === maxRetries) {
                        throw error; // Throw error after all retries failed
                    }
                    
                    // Wait before retry
                    await new Promise(resolve => setTimeout(resolve, delay * attempt));
                }
            }
            return false;
        }

        // Calibration Functions
        async function startCalibration() {
            if (!device || !device.gatt.connected) {
                showError('Please connect to REHABAND device first');
                return;
            }
            
            if (isCalibrating) {
                showError('Calibration already in progress');
                return;
            }
            
            isCalibrating = true;
            calibrationData = [];
            calibrationCount = 0;
            
            calibrateBtn.textContent = 'Calibrating... (0/5)';
            calibrateBtn.style.background = 'linear-gradient(135deg, #dc2626 0%, #b91c1c 100%)';
            calibrateBtn.disabled = true;
            sessionControlsStatus.textContent = 'Calibrating... Perform 5 good form squats';
            
            // Send calibration start command to Arduino with retry logic
            if (calibrationChar) {
                try {
                    await writeCharacteristicWithRetry(calibrationChar, new Uint8Array([1]));
                    console.log('Calibration start command sent to Arduino');
                } catch (error) {
                    console.error('Failed to send calibration command after retries:', error);
                    showError(`Calibration error: ${error.message}`);
                    
                    // Reset calibration state on failure
                    isCalibrating = false;
                    calibrateBtn.textContent = 'Calibrate (5 Reps)';
                    calibrateBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    calibrateBtn.disabled = false;
                    sessionControlsStatus.textContent = 'Ready to start session or calibrate';
                    return;
                }
            }
            
            // Send current target values to Arduino
            await sendSettingsToArduino();
            
            // Clear previous data
            repsData = [];
            lastRepCount = 0;
            
            // Clear rep history
            repContainer.innerHTML = '<div style="text-align: center; color: #667eea; font-size: 12px; padding: 20px;">Calibration in progress... Perform 5 good form squats.</div>';
            
            showError('Calibration started! Perform 5 squats with your best form.');
        }

        function handleCalibrationRep(rom, speed, jerkiness) {
            if (!isCalibrating) return;
            
            calibrationCount++;
            calibrationData.push({ rom, speed, jerkiness });
            
            calibrateBtn.textContent = `Calibrating... (${calibrationCount}/5)`;
            
            if (calibrationCount >= 5) {
                completeCalibration();
            }
        }

        function completeCalibration() {
            if (calibrationData.length < 5) return;
            
            // Calculate averages
            const avgROM = Math.round(calibrationData.reduce((sum, rep) => sum + rep.rom, 0) / calibrationData.length);
            const avgSpeed = parseFloat((calibrationData.reduce((sum, rep) => sum + rep.speed, 0) / calibrationData.length).toFixed(1));
            
            // Update settings with calibrated values
            settings.targetROM = avgROM;
            settings.speedTarget = avgSpeed;
            
            // Update display
            updateSettingDisplay('rom', avgROM);
            updateSettingDisplay('speed', avgSpeed);
            
            // Save to localStorage
            saveSettings();
            
            // Reset calibration state
            isCalibrating = false;
            calibrateBtn.textContent = 'Calibrate (5 Reps)';
            calibrateBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            calibrateBtn.disabled = false;
            sessionControlsStatus.textContent = 'Calibration complete! Ready for sessions';
            
            // Reset rep data
            repsData = [];
            lastRepCount = 0;
            
            // Clear rep history
            repContainer.innerHTML = '<div style="text-align: center; color: #999; font-size: 12px; padding: 20px;" id="noRepsMessage">Calibration complete! Start exercising to see data!</div>';
            
            showError(`Calibration complete! New targets: ${avgROM}° ROM, ${avgSpeed}s speed`);
            setTimeout(hideError, 5000);
        }

        // Demo Mode Functions
        function startDemoMode() {
            hideError();
            
            // Simulate connection
            statusDot.classList.add('connected');
            statusText.textContent = 'Connected (Demo)';
            connectBtn.style.display = 'none';
            demoBtn.textContent = 'Demo Running...';
            demoBtn.disabled = true;
            demoBtn.style.background = 'linear-gradient(135deg, #dc2626 0%, #b91c1c 100%)';
            
            // Show demo disclaimer
            demoDisclaimer.style.display = 'block';
            
            sessionStartTime = Date.now();
            updateDuration();
            
            // Generate demo reps with delays
            simulateReps();
        }

        function simulateReps() {
            const demoReps = [
                { rep: 1, rom: 90, speed: 25.0, jerkiness: 40.0 }, // Good squat (parallel squat, controlled speed, smooth)
                { rep: 2, rom: 70, speed: 42.0, jerkiness: 120.0 }, // Caution squat (shallow squat, moderate speed, some jerk)
                { rep: 3, rom: 95, speed: 28.0, jerkiness: 45.0 }, // Good squat (good depth, controlled speed, smooth)
                { rep: 4, rom: 45, speed: 55.0, jerkiness: 200.0 }, // Poor squat (quarter squat - too shallow, too fast, jerky)
                { rep: 5, rom: 80, speed: 40.0, jerkiness: 100.0 }, // Caution squat (decent depth, moderate speed, some jerk)
            ];

            let currentRep = 0;
            
            function addNextRep() {
                if (currentRep < demoReps.length) {
                    const rep = demoReps[currentRep];
                    addRepCard(rep.rep, rep.rom, rep.speed, rep.jerkiness);
                    updateSummary();
                    currentRep++;
                    
                    // Schedule next rep (2-4 seconds apart)
                    const delay = 2000 + Math.random() * 2000;
                    setTimeout(addNextRep, delay);
                } else {
                    // Demo complete
                    demoBtn.textContent = 'Demo Complete ✓';
                    demoBtn.style.background = '#16a34a';
                    
                    // Show completion message
                    setTimeout(() => {
                        showError('Demo complete! This is how the interface looks with real Arduino data.');
                        
                        // Reset demo after 10 seconds
                        setTimeout(() => {
                            resetDemo();
                        }, 10000);
                    }, 1000);
                }
            }
            
            // Start first rep after 1 second
            setTimeout(addNextRep, 1000);
        }

        function resetDemo() {
            // Reset UI state
            statusDot.classList.remove('connected');
            statusText.textContent = 'Not Connected';
            connectBtn.style.display = '';
            demoBtn.textContent = 'Try Demo Mode';
            demoBtn.disabled = false;
            demoBtn.style.background = 'linear-gradient(135deg, #16a34a 0%, #15803d 100%)';
            
            // Hide demo disclaimer
            demoDisclaimer.style.display = 'none';
            
            // Clear rep data
            repsData = [];
            sessionStartTime = null;
            
            // Reset stats
            document.getElementById('totalReps').textContent = '0';
            document.getElementById('goodReps').textContent = '0';
            document.getElementById('avgAngle').textContent = '--';
            document.getElementById('duration').textContent = '0 mins';
            
            // Clear rep cards
            repContainer.innerHTML = '<div style="text-align: center; color: #999; font-size: 12px; padding: 20px;" id="noRepsMessage">No reps yet. Start exercising to see data!</div>';
            
            hideError();
        }

        // Settings Management Functions
        // Function to send current settings to Arduino
        async function sendSettingsToArduino() {
            if (targetROMChar && targetSpeedChar && isConnected) {
                try {
                    await writeCharacteristicWithRetry(targetROMChar, new Float32Array([settings.targetROM]));
                    await writeCharacteristicWithRetry(targetSpeedChar, new Float32Array([settings.speedTarget]));
                    console.log(`Settings sent to Arduino: ROM=${settings.targetROM}°, Speed=${settings.speedTarget}°/s`);
                } catch (error) {
                    console.error('Failed to send settings to Arduino:', error);
                }
            }
        }

        function adjustSetting(type, change) {
            if (type === 'rom') {
                settings.targetROM = Math.max(30, Math.min(150, settings.targetROM + change));
                updateSettingDisplay('rom', settings.targetROM);
            } else if (type === 'speed') {
                settings.speedTarget = Math.max(20.0, Math.min(50.0, parseFloat((settings.speedTarget + change).toFixed(1))));
                updateSettingDisplay('speed', settings.speedTarget);
            }
            
            // Save to localStorage
            saveSettings();
            
            // Send updated settings to Arduino immediately if connected
            sendSettingsToArduino();
            
            // Visual feedback
            animateSettingChange(type);
        }

        function updateSettingDisplay(type, value) {
            if (type === 'rom') {
                romValue.innerHTML = `${value}<span class="control-unit">°</span>`;
            } else if (type === 'speed') {
                speedValue.innerHTML = `${Math.round(value)}<span class="control-unit">°/s</span>`;
            }
        }

        function animateSettingChange(type) {
            const element = type === 'rom' ? romValue : speedValue;
            element.classList.add('updated');
            setTimeout(() => {
                element.classList.remove('updated');
            }, 300);
        }

        function saveSettings() {
            localStorage.setItem('rehabandSettings', JSON.stringify(settings));
        }

        function loadSettings() {
            const saved = localStorage.getItem('rehabandSettings');
            if (saved) {
                const savedSettings = JSON.parse(saved);
                settings.targetROM = savedSettings.targetROM || 95;
                settings.speedTarget = savedSettings.speedTarget || 30.0;
                settings.soundAlerts = savedSettings.soundAlerts !== undefined ? savedSettings.soundAlerts : true;
                
                // Update display
                updateSettingDisplay('rom', settings.targetROM);
                updateSettingDisplay('speed', settings.speedTarget);
                updateSoundToggleDisplay();
            }
        }

        // Sound Alert Functions
        function playSoundAlert(overallBadge) {
            // Only beep for poor form - no sound for good form
            if (overallBadge === 'caution') {
                playTone(600, 0.15, 0.3); // Warning tone: medium pitch, short
            } else if (overallBadge === 'bad') {
                playTone(300, 0.4, 0.4); // Alert tone: lower pitch, longer
            }
            // No sound for 'good' - silent success
        }

        function playTone(frequency, duration, volume = 0.3) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (error) {
                console.log('Audio not supported or blocked:', error);
            }
        }

        function toggleSoundAlerts() {
            settings.soundAlerts = !settings.soundAlerts;
            updateSoundToggleDisplay();
            saveSettings();
            
            // Play test sound when enabling
            if (settings.soundAlerts) {
                playTone(600, 0.15, 0.3);
            }
        }

        function updateSoundToggleDisplay() {
            soundToggleBtn.textContent = settings.soundAlerts ? 'ON' : 'OFF';
            soundToggleBtn.style.background = settings.soundAlerts ? '#16a34a' : '#ef4444';
            soundToggleBtn.style.color = 'white';
        }

        // Add some visual feedback for testing
        document.addEventListener('DOMContentLoaded', () => {
            console.log('REHABAND BLE App loaded');
            loadSettings(); // Load saved settings on page load
        });
    </script>
</body>
</html>